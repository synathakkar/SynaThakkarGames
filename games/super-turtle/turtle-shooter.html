<!DOCTYPE html>
<html>
<head>
    <title>Super Turtle: Precision Control</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0; overflow: hidden; background-color: #222;
            font-family: 'Press Start 2P', cursive; user-select: none;
            touch-action: none; /* Critical for mobile controls */
        }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: auto; z-index: 100;
            display: flex; flex-direction: column; align-items: center;
        }

        /* Top Bar */
        #top-bar {
            width: 100%; display: flex; justify-content: space-between; padding: 20px; box-sizing: border-box; pointer-events: none;
        }

        #hud {
            background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(4px);
            padding: 10px 25px; border-radius: 50px; border: 3px solid #FFD700;
            color: #FFD700; font-size: 20px; display: flex; align-items: center; gap: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); pointer-events: auto;
        }

        .icon-btn {
            width: 50px; height: 50px; background: rgba(255,255,255,0.2);
            border: 3px solid white; border-radius: 50%; color: white;
            font-size: 20px; cursor: pointer; display: flex; justify-content: center; align-items: center;
            transition: transform 0.1s; backdrop-filter: blur(4px); pointer-events: auto;
        }
        .icon-btn:active { transform: scale(0.9); background: rgba(255,255,255,0.4); }

        .hud-coin {
            width: 24px; height: 24px; background-color: #FFD700; border-radius: 50%;
            position: relative; box-shadow: 0 0 5px #FFD700; border: 2px solid #DAA520;
            animation: bob 1s infinite alternate ease-in-out;
        }
        .hud-coin::after { content: ''; position: absolute; top: 4px; left: 4px; width: 6px; height: 6px; background-color: white; border-radius: 50%; }
        @keyframes bob { from { transform: translateY(0); } to { transform: translateY(-3px); } }

        /* Screens */
        .screen {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; color: white; text-shadow: 4px 4px 0 #000;
            background: rgba(0, 0, 0, 0.9); padding: 40px; border-radius: 20px;
            border: 4px solid #fff; pointer-events: auto; display: none;
            width: 80%; max-width: 400px;
        }
        h1 { font-size: 30px; margin-bottom: 20px; color: #76FF03; line-height: 1.5; }
        p { font-size: 12px; line-height: 20px; color: #ccc; margin-bottom: 20px; }
        
        button.action-btn {
            padding: 15px 30px; font-family: inherit; font-size: 16px;
            background: #FFD700; color: black; border: 4px solid #fff; cursor: pointer;
            box-shadow: 0 5px 0 #b8860b; transition: transform 0.1s; border-radius: 10px; width: 100%; margin-top: 10px;
        }
        button.action-btn:active { transform: translateY(5px); box-shadow: 0 0 0; }
        
        .toggle-row { display: flex; justify-content: space-between; align-items: center; margin: 20px 0; font-size: 14px; }

        /* VISIBLE CONTROLS (Joystick/Jump) */
        #mobile-controls {
            position: absolute; bottom: 20px; left: 0; width: 100%; height: 150px;
            pointer-events: none; z-index: 101; display: flex; justify-content: space-between; padding: 0 40px; box-sizing: border-box;
        }
        .control-zone { pointer-events: auto; position: relative; cursor: pointer; }
        #joystick-base {
            width: 120px; height: 120px; background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 50%; position: relative; backdrop-filter: blur(2px);
        }
        #joystick-knob {
            width: 50px; height: 50px; background: #76FF03; border-radius: 50%;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            box-shadow: 0 4px 0 #388E3C; transition: transform 0.1s;
        }
        #jump-btn {
            width: 100px; height: 100px; background: rgba(255, 215, 0, 0.2);
            border: 4px solid #FFD700; border-radius: 50%; display: flex; justify-content: center; align-items: center;
            color: white; font-size: 14px; font-weight: bold; text-shadow: 2px 2px 0 #000; backdrop-filter: blur(2px);
            user-select: none;
        }
        #jump-btn:active { background: rgba(255, 215, 0, 0.5); transform: scale(0.95); }
        
        #start-screen { display: block; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="top-bar">
            <div id="hud">
                <div class="hud-coin"></div>
                <span id="score-val">0</span>
            </div>
            <div style="display: flex; gap: 10px;">
                <div class="icon-btn" onclick="toggleMenu()">‚öôÔ∏è</div>
                <div class="icon-btn" onclick="togglePause()">‚è∏</div>
            </div>
        </div>

        <div id="start-screen" class="screen">
            <h1>SUPER TURTLE</h1>
            <p>TAP LEFT/RIGHT TO MOVE<br>DOUBLE TAP TO JUMP</p>
            <button class="action-btn" onclick="startGame()">START GAME</button>
        </div>

        <div id="pause-screen" class="screen">
            <h1>PAUSED</h1>
            <button class="action-btn" onclick="togglePause()">RESUME</button>
            <button class="action-btn" onclick="toggleMenu()">SETTINGS</button>
        </div>

        <div id="menu-screen" class="screen">
            <h1>SETTINGS</h1>
            <div class="toggle-row">
                <span>SOUND & MUSIC</span>
                <div class="icon-btn" id="sound-toggle" onclick="toggleSound()">üîä</div>
            </div>
            <button class="action-btn" onclick="closeMenu()">CLOSE</button>
        </div>

        <div id="game-over-screen" class="screen">
            <h1 style="color: #FF5252;">GAME OVER</h1>
            <p>SCORE: <span id="final-score">0</span></p>
            <button class="action-btn" onclick="resetGame()">RETRY</button>
        </div>

        <div id="mobile-controls">
            <div class="control-zone" id="joystick-zone">
                <div id="joystick-base"><div id="joystick-knob"></div></div>
            </div>
            <div class="control-zone" id="jump-zone"><div id="jump-btn">JUMP</div></div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score-val');
    const finalScoreEl = document.getElementById('final-score');
    
    // Screens
    const startScreen = document.getElementById('start-screen');
    const pauseScreen = document.getElementById('pause-screen');
    const menuScreen = document.getElementById('menu-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const soundToggleBtn = document.getElementById('sound-toggle');
    const uiLayer = document.getElementById('ui-layer');

    // Controls
    const joystickZone = document.getElementById('joystick-zone');
    const joystickKnob = document.getElementById('joystick-knob');
    const jumpBtn = document.getElementById('jump-btn');

    // --- AUDIO SYSTEM ---
    const AudioSys = {
        ctx: null, enabled: true, bgmTimer: null, melodyIndex: 0,
        melody: [261.6, 329.6, 392.0, 493.9, 523.3, 392.0, 329.6, 392.0], 
        init: function() { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); if (this.ctx.state === 'suspended') this.ctx.resume(); },
        play: function(type) {
            if (!this.enabled || !this.ctx) return;
            const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
            osc.connect(gain); gain.connect(this.ctx.destination); const now = this.ctx.currentTime;
            if (type === 'jump') {
                osc.type = 'square'; osc.frequency.setValueAtTime(150, now); osc.frequency.linearRampToValueAtTime(300, now+0.1);
                gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now+0.1);
                osc.start(now); osc.stop(now+0.1);
            } else if (type === 'coin') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(1200, now); osc.frequency.exponentialRampToValueAtTime(1800, now+0.1);
                gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now+0.3);
                osc.start(now); osc.stop(now+0.3);
            } else if (type === 'die') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, now); osc.frequency.exponentialRampToValueAtTime(50, now+0.5);
                gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now+0.5);
                osc.start(now); osc.stop(now+0.5);
            } else if (type === 'click') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(600, now);
                gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now+0.05);
                osc.start(now); osc.stop(now+0.05);
            }
        },
        startMusic: function() { if(this.bgmTimer) return; this.playNextNote(); },
        stopMusic: function() { if(this.bgmTimer) clearTimeout(this.bgmTimer); this.bgmTimer = null; },
        playNextNote: function() {
            if (!this.enabled || !this.ctx) { this.bgmTimer = setTimeout(() => this.playNextNote(), 1000); return; }
            const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter(); filter.type = "lowpass"; filter.frequency.value = 800;
            osc.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
            const now = this.ctx.currentTime; const freq = this.melody[this.melodyIndex];
            osc.type = 'triangle'; osc.frequency.setValueAtTime(freq, now);
            gain.gain.setValueAtTime(0, now); gain.gain.linearRampToValueAtTime(0.03, now + 0.1); gain.gain.linearRampToValueAtTime(0, now + 0.6);
            osc.start(now); osc.stop(now + 0.6);
            this.melodyIndex = (this.melodyIndex + 1) % this.melody.length;
            this.bgmTimer = setTimeout(() => this.playNextNote(), 300);
        }
    };

    // --- GAME CONSTANTS ---
    const COLORS = { skyTop: "#4FC3F7", skyBottom: "#E1F5FE", ground: "#5D4037", grass: "#64DD17", mountBack: "#455A64", mountFront: "#607D8B" };
    
    // --- STATE ---
    let gameState = "START"; let prevGameState = "START";
    let gameFrame = 0; let score = 0;
    let cameraX = 0; let groundBaseY = 0; let nextGenX = 0; let currentZoom = 1.0; 
    
    const platforms = []; const coins = []; const particles = []; const mountains = [];
    const clouds = []; const birds = []; 
    
    // Reduced speed to 6 for better control
    const player = { x: 0, y: 0, w: 40, h: 40, dx: 0, dy: 0, speed: 6, jumpPower: -17, gravity: 0.9, grounded: false, state: "idle", facingRight: true, jumpCount: 0, maxJumps: 2, rotation: 0 };
    
    // INPUT STATE
    const input = { left: false, right: false };
    let joystickActive = false; let joystickOriginX = 0;
    
    // Tap Logic
    let lastTapTime = 0;
    let touchLeft = false;
    let touchRight = false;

    function init() {
        resize();
        for(let i=0; i<50; i++) platforms.push({ active: false });
        for(let i=0; i<150; i++) coins.push({ active: false, bob: Math.random() });
        for(let i=0; i<50; i++) particles.push({ active: false });
        for(let i=0; i<3; i++) mountains.push({ x: i * 2000 - 1000, layer: 0, w: 2001, h: 800, totalW: 6000 }); 
        for(let i=0; i<3; i++) mountains.push({ x: i * 1500 - 500, layer: 1, w: 1501, h: 500, totalW: 4500 });
        for(let i=0; i<5; i++) clouds.push({ x: Math.random() * 2000, y: Math.random() * 300, w: 100 + Math.random()*100, speed: 0.2 + Math.random()*0.3 });
        for(let i=0; i<5; i++) birds.push({ x: Math.random() * 2000, y: Math.random() * 400, speed: 2 + Math.random(), offset: Math.random()*10 });

        resetGameLogic();
        requestAnimationFrame(loop);
    }

    function resize() {
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        groundBaseY = canvas.height * 0.75; 
        currentZoom = (canvas.width < 600) ? 0.8 : 1.0;
    }
    window.addEventListener('resize', resize);

    // --- UI ACTIONS ---
    window.startGame = function() {
        AudioSys.init(); AudioSys.play('click'); AudioSys.startMusic();
        startScreen.style.display = "none"; gameState = "PLAYING"; player.dy = -10; 
    };
    window.resetGame = function() {
        AudioSys.play('click'); AudioSys.startMusic();
        gameOverScreen.style.display = "none"; resetGameLogic(); gameState = "PLAYING"; player.dy = -10; 
    };
    window.togglePause = function() {
        AudioSys.play('click');
        if (gameState === "PLAYING") { gameState = "PAUSED"; pauseScreen.style.display = "block"; AudioSys.stopMusic(); } 
        else if (gameState === "PAUSED") { gameState = "PLAYING"; pauseScreen.style.display = "none"; AudioSys.startMusic(); }
    };
    window.toggleMenu = function() {
        AudioSys.play('click');
        if (gameState !== "MENU") {
            prevGameState = gameState; gameState = "MENU";
            pauseScreen.style.display = "none"; startScreen.style.display = "none";
            menuScreen.style.display = "block";
        }
    };
    window.closeMenu = function() {
        AudioSys.play('click'); menuScreen.style.display = "none"; gameState = prevGameState;
        if (gameState === "PAUSED") pauseScreen.style.display = "block";
        if (gameState === "START") startScreen.style.display = "block";
    };
    window.toggleSound = function() {
        AudioSys.enabled = !AudioSys.enabled;
        soundToggleBtn.innerText = AudioSys.enabled ? "üîä" : "üîá";
        AudioSys.play('click');
        if(AudioSys.enabled && gameState === "PLAYING") AudioSys.startMusic();
        if(!AudioSys.enabled) AudioSys.stopMusic();
    };

    function resetGameLogic() {
        score = 0; scoreEl.innerText = "0"; gameFrame = 0;
        player.x = 200; player.y = groundBaseY - 300; player.dx = 0; player.dy = 0; player.rotation = 0; cameraX = 0;
        platforms.forEach(p => p.active = false); coins.forEach(c => c.active = false); particles.forEach(p => p.active = false);
        spawnPlatform(-500, groundBaseY, 2000, 'ground'); nextGenX = 1500;
        touchLeft = false; touchRight = false; input.left = false; input.right = false;
    }

    // --- UPDATE ---
    function update() {
        if(gameState === "PAUSED" || gameState === "MENU") return;

        if(gameState === "START") {
            gameFrame++; player.x = canvas.width/(2*currentZoom) - 20; player.y = canvas.height/(2*currentZoom) - 120 + Math.sin(gameFrame*0.05)*10;
            player.facingRight = true; return;
        }
        if(gameState === "GAMEOVER") return;
        gameFrame++;

        if (nextGenX < cameraX + (canvas.width/currentZoom) + 1000) generatePattern();
        const deleteX = cameraX - 1000;
        platforms.forEach(p => { if(p.active && p.x + p.w < deleteX) p.active = false; });
        coins.forEach(c => { if(c.active && c.x < deleteX) c.active = false; });

        // --- HYBRID MOVEMENT LOGIC ---
        let moveLeft = input.left || touchLeft;
        let moveRight = input.right || touchRight;

        if(moveLeft) { player.dx = -player.speed; player.facingRight = false; player.state = "walk"; }
        else if(moveRight) { player.dx = player.speed; player.facingRight = true; player.state = "walk"; }
        else { 
            // Friction stop
            player.dx *= 0.5; 
            if(Math.abs(player.dx) < 0.1) player.dx = 0;
            player.state = "idle"; 
        }

        player.dy += player.gravity; player.x += player.dx; player.y += player.dy;
        if (player.rotation > 0) player.rotation -= 20; if (player.rotation < 0) player.rotation = 0;

        player.grounded = false;
        for(let p of platforms) {
            if(!p.active) continue;
            if (player.x + player.w > p.x + 5 && player.x < p.x + p.w - 5 &&
                player.y + player.h >= p.y && player.y + player.h <= p.y + p.h + 25 && player.dy >= 0) {
                player.dy = 0; player.y = p.y - player.h; player.grounded = true; player.jumpCount = 0;
            }
        }
        if(!player.grounded) player.state = "jump";
        if(player.y > canvas.height/currentZoom + 200) { 
            AudioSys.play('die'); AudioSys.stopMusic();
            gameState = "GAMEOVER"; finalScoreEl.innerText = score; gameOverScreen.style.display = "block"; 
        }

        let targetCamX = player.x - (canvas.width/(2*currentZoom)) * 0.5;
        cameraX += (targetCamX - cameraX) * 0.1;

        coins.forEach(c => {
            if(!c.active) return;
            if(Math.sqrt((player.x+20 - c.x)**2 + (player.y+20 - c.y)**2) < 40) {
                c.active = false; score++; scoreEl.innerText = score; 
                AudioSys.play('coin'); spawnParticles(c.x, c.y, "gold");
            }
        });

        mountains.forEach(m => { let parallax = (m.layer === 0 ? 0.1 : 0.3); if((m.x - (cameraX * parallax)) + m.w < -100) m.x += m.totalW; });
        clouds.forEach(c => { c.x += c.speed; let relX = c.x - (cameraX * 0.05); if (relX > canvas.width/currentZoom + 200) c.x -= (canvas.width/currentZoom + 400); });
        birds.forEach(b => { b.x += b.speed; if (b.x > cameraX + canvas.width/currentZoom + 100) b.x = cameraX - 200; });
        particles.forEach(p => { if(!p.active) return; p.x += p.vx; p.y += p.vy; p.life -= 0.05; p.vy += 0.2; if(p.life <= 0) p.active = false; });
    }

    function spawnPlatform(x, y, w, type) { let p = platforms.find(i => !i.active); if(p) { p.active = true; p.x = x; p.y = y; p.w = w; p.h = (type==='float'?30:canvas.height); p.type = type; } }
    function spawnCoin(x, y) { let c = coins.find(i => !i.active); if(c) { c.active = true; c.x = x; c.y = y; } }
    function spawnParticles(x, y, type) {
        let count = 0; let limit = (type === "gold") ? 8 : 5;
        for(let p of particles) {
            if(!p.active && count < limit) {
                p.active = true; p.x = x; p.y = y; p.life = 1.0; p.type = type;
                if (type === "gold") { p.vx = (Math.random()-0.5)*8; p.vy = (Math.random()-0.5)*8; p.color = `hsl(${45+Math.random()*10},100%,50%)`; p.size = 3+Math.random()*3; } 
                else { p.vx = (Math.random()-0.5)*4; p.vy = Math.random()*-3; p.color = "rgba(255,255,255,0.6)"; p.size = 2+Math.random()*4; }
                count++;
            }
        }
    }

    function spawnCoinPattern(x, y) {
        const pattern = Math.floor(Math.random() * 5);
        if(pattern === 0) { for(let i=0; i<5; i++) spawnCoin(x + i*50, y); }
        else if(pattern === 1) { for(let i=0; i<5; i++) spawnCoin(x + i*50, y - Math.sin(i*0.8)*50); }
        else if(pattern === 2) { spawnCoin(x, y); spawnCoin(x+30, y-30); spawnCoin(x+60, y-60); spawnCoin(x+90, y-30); spawnCoin(x+120, y); }
        else if(pattern === 3) { for(let i=0; i<3; i++) spawnCoin(x+60, y - i*40); }
        else if(pattern === 4) { for(let i=0; i<4; i++) spawnCoin(x + i*60, y + 30); }
    }

    function generatePattern() {
        const pattern = Math.floor(Math.random() * 4); 
        let w = 300 + Math.random() * 300; let gap = 150 + Math.random() * 100; let sx = nextGenX + gap;
        if (pattern === 0) { spawnPlatform(sx, groundBaseY, w, 'ground'); spawnCoinPattern(sx + 100, groundBaseY - 50); nextGenX = sx + w; } 
        else if (pattern === 1) { spawnPlatform(sx, groundBaseY, 600, 'ground'); spawnPlatform(sx + 50, groundBaseY - 120, 150, 'float'); spawnPlatform(sx + 300, groundBaseY - 220, 150, 'float'); spawnCoinPattern(sx + 50, groundBaseY - 160); nextGenX = sx + 600; } 
        else if (pattern === 2) { let step = 150; spawnPlatform(sx, groundBaseY, step, 'ground'); spawnPlatform(sx + step + 20, groundBaseY - 70, step, 'ground'); spawnPlatform(sx + (step*2) + 40, groundBaseY - 140, step, 'ground'); spawnCoinPattern(sx + (step*2), groundBaseY - 180); nextGenX = sx + (step*3) + 40; } 
        else { gap += 100; spawnPlatform(nextGenX + gap, groundBaseY, w, 'ground'); spawnCoinPattern(nextGenX + gap/2 - 100, groundBaseY - 100); nextGenX = nextGenX + gap + w; }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        let grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, COLORS.skyTop); grad.addColorStop(1, COLORS.skyBottom);
        ctx.fillStyle = grad; ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.save(); ctx.scale(currentZoom, currentZoom);
        if(gameState !== "START") ctx.translate(-cameraX, 0);

        clouds.forEach(c => { let pX = cameraX * 0.05; let dX = c.x + pX; ctx.fillStyle = "rgba(255, 255, 255, 0.4)"; ctx.beginPath(); ctx.arc(dX, c.y, c.w/2, 0, Math.PI*2); ctx.arc(dX+c.w*0.4, c.y-20, c.w/2.5, 0, Math.PI*2); ctx.fill(); });
        mountains.forEach(m => { let parallax = (m.layer === 0 ? 0.1 : 0.3); ctx.fillStyle = (m.layer === 0 ? COLORS.mountBack : COLORS.mountFront); ctx.beginPath(); let dX = m.x - (gameState !== "START" ? (cameraX * parallax) : 0); dX += (gameState !== "START" ? cameraX : 0); ctx.moveTo(dX, canvas.height/currentZoom); ctx.lineTo(dX + m.w*0.3, (canvas.height/currentZoom) - m.h); ctx.lineTo(dX + m.w*0.7, (canvas.height/currentZoom) - m.h*0.7); ctx.lineTo(dX + m.w, canvas.height/currentZoom); ctx.fill(); });
        birds.forEach(b => { let flyY = Math.sin(gameFrame*0.2 + b.offset) * 5; ctx.strokeStyle = "black"; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(b.x, b.y + flyY); ctx.lineTo(b.x - 10, b.y - 5 + flyY); ctx.moveTo(b.x, b.y + flyY); ctx.lineTo(b.x + 10, b.y - 5 + flyY); ctx.stroke(); });
        platforms.forEach(p => { if(!p.active) return; ctx.fillStyle = COLORS.ground; let drawH = (p.type === 'float') ? 40 : (canvas.height/currentZoom - p.y); ctx.fillRect(p.x, p.y, p.w, drawH); ctx.fillStyle = COLORS.grass; ctx.fillRect(p.x, p.y, p.w, 20); ctx.fillStyle = "#AEEA00"; ctx.fillRect(p.x, p.y, p.w, 5); });
        coins.forEach(c => { if(!c.active) return; let bob = Math.sin(gameFrame*0.1 + c.bob) * 5; ctx.fillStyle = "#FFD700"; ctx.beginPath(); ctx.arc(c.x, c.y + bob, 12, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = "#FFF"; ctx.beginPath(); ctx.arc(c.x-4, c.y+bob-4, 3, 0, Math.PI*2); ctx.fill(); });
        drawTurtleOriginal(player.x, player.y);
        particles.forEach(p => { if(!p.active) return; ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1.0; });
        ctx.restore();
    }

    function drawTurtleOriginal(x, y) {
        ctx.save(); ctx.translate(x + 20, y + 20); 
        if (!player.facingRight) ctx.scale(-1, 1);
        if (player.rotation > 0) ctx.rotate(player.rotation * Math.PI / 180);
        ctx.translate(-(x + 20), -(y + 20));
        let legOffset = (player.state === "walk") ? Math.sin(gameFrame * 0.3) * 5 : (player.state === "jump" ? -5 : 0);
        ctx.fillStyle = "#228B22"; ctx.beginPath(); ctx.arc(x + 10 + legOffset, y + 38, 7, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(x + 30 - legOffset, y + 38, 7, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = "#32CD32"; ctx.beginPath(); ctx.ellipse(x + 20, y + 22, 22, 18, 0, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = "#98FB98"; ctx.beginPath(); ctx.ellipse(x + 20, y + 25, 14, 10, 0, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = "#32CD32"; ctx.beginPath(); ctx.arc(x + 36, y + 15, 13, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(x + 38, y + 12, 5, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = "black"; ctx.beginPath(); ctx.arc(x + 40, y + 12, 2, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
    }

    function doJump() {
        if(gameState === "START") startGame();
        else if(gameState === "GAMEOVER") resetGame();
        else if(player.grounded || player.jumpCount < player.maxJumps) {
            AudioSys.play('jump'); player.dy = player.jumpPower; player.grounded = false; player.jumpCount++;
            spawnParticles(player.x+20, player.y+40, "dust");
            if(player.jumpCount > 1) player.rotation = 360;
        }
    }

    // --- UNIVERSAL INPUT HANDLER ---
    // Handles Screen Taps (Left/Right) + Double Tap Jump
    function handleScreenTouch(e) {
        if(gameState !== "PLAYING") return;
        
        // Ignore if touching controls or buttons
        if(e.target.closest('.control-zone') || e.target.closest('.icon-btn') || e.target.closest('.action-btn')) return;

        const touchX = e.touches[0].clientX;
        const now = Date.now();

        // Double Tap Detection
        if(now - lastTapTime < 300) {
            doJump();
        }
        lastTapTime = now;

        // Direction Detection
        if (touchX < window.innerWidth / 2) {
            touchLeft = true; touchRight = false;
        } else {
            touchRight = true; touchLeft = false;
        }
    }

    // Keyboard
    document.addEventListener('keydown', e => {
        if(e.code === "Space") doJump();
        if(e.code === "KeyA" || e.code === "ArrowLeft") input.left = true;
        if(e.code === "KeyD" || e.code === "ArrowRight") input.right = true;
        if(e.code === "Escape") togglePause();
    });
    document.addEventListener('keyup', e => {
        if(e.code === "KeyA" || e.code === "ArrowLeft") input.left = false;
        if(e.code === "KeyD" || e.code === "ArrowRight") input.right = false;
    });

    // Screen Taps (Background Layer)
    uiLayer.addEventListener('touchstart', handleScreenTouch);
    uiLayer.addEventListener('touchend', () => { touchLeft = false; touchRight = false; });
    
    // PC Mouse Click on sides (Simulate touch)
    uiLayer.addEventListener('mousedown', (e) => {
        if(gameState !== "PLAYING" || e.target.closest('.control-zone') || e.target.closest('button')) return;
        if(e.clientX < window.innerWidth/2) touchLeft = true;
        else touchRight = true;
    });
    uiLayer.addEventListener('mouseup', () => { touchLeft = false; touchRight = false; });

    // On-Screen Controls (Mouse + Touch)
    function startJoy(x) { joystickActive = true; joystickOriginX = x; joystickKnob.style.transition = "none"; }
    function moveJoy(x) {
        if(!joystickActive) return;
        let deltaX = x - joystickOriginX;
        let visualDelta = Math.max(-35, Math.min(35, deltaX));
        joystickKnob.style.transform = `translate(-50%, -50%) translateX(${visualDelta}px)`;
        if(deltaX > 20) { input.right = true; input.left = false; }
        else if(deltaX < -20) { input.left = true; input.right = false; }
        else { input.left = false; input.right = false; }
    }
    function endJoy() {
        joystickActive = false; input.left = false; input.right = false;
        joystickKnob.style.transform = `translate(-50%, -50%)`; joystickKnob.style.transition = "transform 0.1s";
    }

    // Joystick Listeners
    joystickZone.addEventListener('mousedown', e => { e.preventDefault(); startJoy(e.clientX); });
    joystickZone.addEventListener('touchstart', e => { e.preventDefault(); startJoy(e.touches[0].clientX); });
    
    window.addEventListener('mousemove', e => { if(joystickActive) { e.preventDefault(); moveJoy(e.clientX); } });
    joystickZone.addEventListener('touchmove', e => { e.preventDefault(); moveJoy(e.touches[0].clientX); });
    
    window.addEventListener('mouseup', endJoy);
    joystickZone.addEventListener('touchend', endJoy);

    // Jump Button Listeners
    const triggerJump = (e) => { e.preventDefault(); doJump(); };
    jumpBtn.addEventListener('mousedown', triggerJump);
    jumpBtn.addEventListener('touchstart', triggerJump);

    init();
    function loop() { update(); draw(); requestAnimationFrame(loop); }

</script>
</body>
</html>